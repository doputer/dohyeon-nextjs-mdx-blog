---
emoji: '🖼️'
title: 'Next.js MDX 이미지 경로 문제 해결'
description: '편의성 측면에서 해결하기'
tags:
  - blog
  - mdx
  - trouble shooting
date: 2024-11-24
---

## 마주친 몇 가지 문제

개발 중 몇 가지 문제를 겪었는데 대부분 Gatsby 플러그인이 자동으로 해주던 기능이 사라져서 생긴 것들이었습니다.

사실 찾아보면 패키지가 있을 것 같긴한데 일부를 직접 해결해봤습니다.

### 이미지 절대 경로

앞서 MDX와 이미지를 같은 곳에서 관리한다고 했습니다. 그래서 저는 MDX에서 이미지를 불러올 때 `![](0.png)`와 같이 상대 경로로 사용했습니다. 기존에는 문제가 없었는데 마이그레이션 이후에 경로를 찾지 못하는 문제가 발생했습니다.

![](0.png '바로 옆에 있는데요?')

요청 URL을 자세히 보니 `(root)/0.png`와 같이 절대 경로로 이미지를 요청하고 있었습니다.

그럼 단순하게 `public` 디렉토리에서 이미지를 관리하면 됐겠지만 그러고 싶지 않았습니다... 이미지를 삽입 할 때마다 디렉토리를 옮겨다니고 각기 다른 파일 이름을 짓느라 고민하는 과정이 복잡해보였습니다.

그래서 이 부분은 스크립트를 이용하기로 했습니다. 방법은 개발 서버를 실행하거나 빌드 할 때 이미지들을 `public` 디렉토리에 복사하는 것입니다. 다만 단순히 `public` 안에 복사하면 모든 이미지 이름이 달라야하기 때문에 `public/images/[포스트 URL]` 안에 복사되도록 했습니다.

```js pre-script.js
import { access, constants, copyFile, mkdir, readdir, rm } from 'fs/promises';
import path from 'path';

const SOURCE_DIR = path.join(process.cwd(), 'contents');
const TARGET_DIR = path.join(process.cwd(), 'public/images');

// !collapse(1:7) collapsed
const exists = async (path) => {
  try {
    await access(path, constants.F_OK);
    return true;
  } catch {
    return false;
  }
};

const copyImages = async () => {
  const entries = await readdir(SOURCE_DIR, { withFileTypes: true });
  const dirs = entries.filter((entry) => entry.isDirectory()).map((entry) => entry.name);

  if (await exists(TARGET_DIR)) await rm(TARGET_DIR, { recursive: true });

  for await (const dir of dirs) {
    const sourceDirPath = path.resolve(path.join(SOURCE_DIR, dir));
    const targetDirPath = path.resolve(path.join(TARGET_DIR, dir));
    const entries = await readdir(sourceDirPath, { withFileTypes: true });
    const files = entries.filter((entry) => !entry.isDirectory()).map((entry) => entry.name);
    // !mark
    const imageFiles = files.filter((file) => /.(png|gif)$/.test(file));

    if (imageFiles.length === 0) continue;

    await mkdir(targetDirPath, { recursive: true });

    await Promise.all(
      imageFiles.map((imageFile) => {
        // !mark(1:2)
        const sourceFilePath = path.resolve(path.join(sourceDirPath, imageFile));
        const targetFilePath = path.resolve(path.join(targetDirPath, imageFile));

        // !mark
        copyFile(sourceFilePath, targetFilePath);
      })
    );
  }
};

await copyImages();
```

![](1.png '잘 복사된 이미지들')

그런데 `public/images/[포스트 URL]` 안에 복사했기 때문에 MDX에서 `![](images/[포스트 URL]/0.png)`와 같이 작성해야됩니다. `![](0.png)`과 같이 같은 디렉토리에 있는 이미지 이름만 입력해도 알아서 잘 찾아주면 얼마나 좋을까요.

간단한 `remark` 플러그인을 만들어서 빌드 단계에서 `img`의 `src`를 수정해보겠습니다.

```js remark-public-image.js
import { visit } from 'unist-util-visit';

const remarkPublicImage = () => {
  return (tree, file) => {
    // file.history => [(root)/[포스트 URL]/index.mdx]
    const path = file.history.at(0).split('/').at(-2);

    visit(tree, 'image', (node) => {
      // !mark
      node.url = `/images/${path}/${node.url}`;
    });
  };
};
```

만든 플러그인은 `next.config.mjs`에 추가해줍니다.

```js
import remarkPublicImage from './scripts/remark-public-image.mjs';

const withMDX = createMDX({
  options: {
    ...
    remarkPlugins: [remarkPublicImage],
  },
});

export default withMDX(nextConfig);
```

<Callout>

MDX 문법으로 작성만 했는데 어떻게 브라우저에 렌더링 되는걸까요?

누군가 변환을 해주고 있습니다. 제 블로그의 경우 `@mdx-js/mdx`가 그 역할을 하고 있습니다.

간략하게 MDX -> MDAST(Markdown Abstract Syntax Tree) -> HAST(HTML Abstract Syntax Tree) -> JSX 순으로 변환됩니다.

플러그인들은 이런 변환 과정에 개입해서 추상 구문 트리를 조작 할 수 있습니다. 제가 플러그인을 만들면서 `unist-util-visit`을 통해 `src`를 수정 할 수 있었던 이유입니다.

</Callout>

이제 마무리되었습니다. 그런데 스크립트를 매번 실행하기 귀찮기 때문에 `package.json`을 수정해줍니다.

```json package.json
"scripts": {
  "prebuild": "node ./scripts/pre-script.mjs",
  "build": "next build",
  "predev": "node ./scripts/pre-script.mjs",
  "dev": "next dev",
}
```

그리고 실행 시 자동으로 생성되기 때문에 원격 저장소에 올라갈 필요가 없습니다. `.gitignore`에도 추가해줍니다.

```json .gitignore
# asset
/public/images/*
```
